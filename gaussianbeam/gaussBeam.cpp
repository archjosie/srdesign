/* PHGN 481 - Twisting Light and Dielectric Media
*  Laguerre-Gaussian Beam Simulation
*  Description: Creates data for plotting the electric field generated by a Gaussian beam (Cartesian coords)
*  Author: Jared Popelar
*
* Author's note: Many processes in this program are data independent of each other, and hence can be
* parallelized to attain lower runtimes. For CilkPlus, using cilk_for loops in the population and
* computation subroutines will automatically handle this. Do NOT try using cilk_for in the writeData() method,
* as it is critical the data is outputted in an organized manner; parallelizing that loop may scramble the
* results, making the generated data file unintelligible to plotting packages such as ROOT or gnuplot.
*/


#include <iostream>
#include <cstdlib>
#include <cmath>
#include <fstream>
#include <vector>
#include <complex>

#include<fftw3.h>

int main(){
    return 0;
}

using namespace std;
const double PI = 3.14159265;

//Prototypes
void calculateGauss(vector<vector<vector<double> > > &ReEField, vector<vector<vector<double> > > &ImEField, vector<double> x, vector<double> y, vector<double> z, double k, double zR, double w0, unsigned int m, unsigned int n);
double calculateWaist(double z, double zR, double w0);
double calculateRadCurv(double z, double zR);
double calculateRayleigh(double w0, double lambda);
double calculateGouy(double z, double zR);
double calculateHermite(double x, unsigned int n);
double distance(double x, double y);
void writeData(vector<vector<vector<double> > > &ReEField, vector<vector<vector<double> > > &ImEField, ofstream &fout, vector<double> x, vector<double> y, vector<double> z);
void snapshotWrite(double k, double w0, double zR, unsigned int m, unsigned int n);
void writeData2(vector<vector<vector<double> > > &ReEField, vector<vector<vector<double> > > &ImEField, ofstream &fout, vector<double> x, vector<double> y);
void fourierTran(vector<vector<vector<double> > > realPart, vector<vector<vector<double> > > imagPart, vector<double> xVals, vector<double> yVals, double z);

//int main(int argc, char** argv) {
//
//	double lambda; //Stores wavelength of beam
//	cout << "Enter the wavelength of the Gaussian beam: " << endl;
//	cin >> lambda;
//
//	double w0; //Stores waist size of beam (easier to specify than zR)
//	cout << "Enter the waist size of the Gaussian beam: " << endl;
//	cin >> w0;
//
//	double xMax; //Stores upper limit on x
//	cout << "Enter the maximum value of x: " << endl;
//	cin >> xMax;
//
//	double xMin; //Stores upper limit on radius of consideration
//	cout << "Enter the minimum value of x: " << endl;
//	cin >> xMin;
//
//	double xInt; //Stores number of radial steps in the data output
//	cout << "Enter the step size on x: " << endl;
//	cin >> xInt;
//
//	double yMax; //Stores upper limit on radius of consideration
//	cout << "Enter the maximum value of y: " << endl;
//	cin >> yMax;
//
//	double yMin; //Stores upper limit on radius of consideration
//	cout << "Enter the minimum value of y: " << endl;
//	cin >> yMin;
//
//	double yInt; //Stores number of radial steps in the data output
//	cout << "Enter the step size on y: " << endl;
//	cin >> yInt;
//
//	double zMin; //Stores lower limit on distance from focus
//	cout << "Enter the minimum distance from focus: " << endl;
//	cin >> zMin;
//
//	double zMax; //Stores upper limit on distance from focus
//	cout << "Enter the maximum distance from focus: " << endl;
//	cin >> zMax;
//
//	double zInt; //Stores number of distance steps in the data output
//	cout << "Enter the step size on z: " << endl;
//	cin >> zInt;
//
//	int n;
//	cout << "Enter angular momentum quantum number for x-direction: " << endl;
//	cin >> n;
//
//	int m;
//	cout << "Enter angular momentum quantum number for y-direction: " << endl;
//	cin >> m;
//
//	vector<double> xVals;
//	vector<double> yVals;
//	vector<double> zVals; //Vectors to store input data
//
//	int xRange = (xMax - xMin) / xInt + 1;
//	int yRange = (yMax - yMin) / yInt + 1;
//	int zRange = (zMax - zMin) / zInt + 1; //"Hackfix" to get as close as possible to max without going over
//
//	for (int i = 0; i < xRange; i++) { //Populate xVals
//		double xCurr = xMin + i*xInt;
//		xVals.push_back(xCurr);
//	}
//
//	for (int i = 0; i < yRange; i++) { //Populate yVals
//		double yCurr = yMin + i*yInt;
//		yVals.push_back(yCurr);
//	}
//
//	for (int i = 0; i < zRange; i++) { //Populate zVals
//		double zCurr = i*zInt + zMin; //We don't want 0 in zVals
//		zVals.push_back(zCurr);
//	}
//
//	double k = lambda / (2 * PI); //Wave number for convenience
//	double zR = calculateRayleigh(w0, lambda); //Rayleigh range
//
//	vector<vector<vector<double> > > ReEField(xVals.size(), vector<vector<double> >(yVals.size(), vector<double>(zVals.size(), 0)));
//	vector<vector<vector<double> > > ImEField(xVals.size(), vector<vector<double> >(yVals.size(), vector<double>(zVals.size(), 0))); //Separate 3D vectors to hold real and imaginary parts of E-field
//
//	calculateGauss(ReEField, ImEField, xVals, yVals, zVals, k, zR, w0, m, n);
//
//	ofstream fout;
//	fout.open("gaussFieldCart.dat");
//	if (fout.fail()) {
//		cerr << "Something went wrong opening output file! Exiting..." << endl;
//		exit(1);
//	}
//
//	//writeData(ReEField, ImEField, fout, xVals, yVals, zVals);
//	fout.close();
//
//	snapshotWrite(k, w0, zR, m, n);
//
//	return 0;
//}

double calculateRadCurv(double z, double zR) {
	return (z*(1 + pow(zR / z, 2)));
}

double calculateGouy(double z, double zR) {
	return atan(z / zR);
}

double calculateWaist(double z, double zR, double w0) {
	return w0*sqrt(1 + pow(z / zR, 2));
}

double calculateRayleigh(double w0, double lambda) {
	return PI * pow(w0, 2) / lambda;
}

double calculateHermite(double x, unsigned int n) { //Calculates the nth Hermite polynomial evaluated at x recursively
	if (n == 0) return 1;
	if (n == 1) return 2 * x; //Base cases

	return (2 * x*calculateHermite(x, n - 1) - 2 * (n - 1)*calculateHermite(x, n - 2));
}

double distance(double x1, double y1) { //Distance formula
	return 0; //pow((pow(x1, 2) + pow(y1, 2)),0.5);
}

void calculateGauss(vector<vector<vector<double> > > &ReEField, vector<vector<vector<double> > > &ImEField, vector<double> x, vector<double> y, vector<double> z, double k, double zR, double w0, unsigned int m, unsigned int n) {
	//Calculates E as a ratio of E0 over a range of r and z values; parallelizable 
	//We're currently ignoring time dependence in this calculation (i.e. All of this happens at t=0)

	//Big constructor incoming
	//vector<vector<vector<complex<double> > > > data(x.size(), vector<vector<double> >(y.size(), vector<double>(z.size(),0))); 

	for (int l = 0; l < z.size(); ++l) {  //Weird choice, but this streamlines the program
    										  //These only vary with z, so we only need to calculate them once per loop
		double gouy = calculateGouy(z.at(l), zR);
		double radCurv = calculateRadCurv(z.at(l), zR);
		double spotSize = calculateWaist(z.at(l), zR, w0);

		for (int i = 0; i < x.size(); ++i) {
			for (int j = 0; j < y.size(); ++j) {

//				double r = distance(4.0, 5.0);
//				//Complex argument for Gaussian E-field
//
//				double imArg = -(k* z.at(l) + k*(pow(r, 2) / (radCurv * 2)) - gouy);
//				complex<double> expArg(0.0, imArg);
//
//				complex<double> phasorOut; //Uncomment if we only want to consider real component of field			
//				phasorOut = calculateHermite(sqrt(2)*x.at(i) / spotSize, m)*calculateHermite(sqrt(2)*y.at(j) / spotSize, n)*(w0 / spotSize)*exp(-pow(r / spotSize, 2))*exp(expArg);
//				double realField = real(phasorOut);
//				double imagField = imag(phasorOut);
//
//				ReEField.at(i).at(j).at(l) = realField;
//				ImEField.at(i).at(j).at(l) = imagField;
			}
		}
	}
}
//
//void writeData(vector<vector<vector<double> > > ReEField, vector<vector<vector<double> > > &ImEField, ofstream &fout, vector<double> x, vector<double> y, vector<double> z) {
//	//Time to write and export the data
//	fout << "# x " << '\t' << "y " << '\t' << "z " << '\t' << "Re(E(x,y,z)) " << '\t' << "Im(E(x,y,z)) " << '\t' << "Abs(E(x,y,z))" << endl; //Pound sign forces gnuplot to ignore line
//
//																																			 //Write our 3D complex vector to file
//	for (int i = 0; i < x.size(); ++i) {
//		for (int j = 0; j < y.size(); ++j) {
//			for (int k = 0; k < z.size(); ++k) {
//
//				//*inhales*
//				fout << x.at(i) << '\t' << y.at(j) << '\t' << z.at(k) << '\t' << ReEField.at(i).at(j).at(k) << '\t' << ImEField.at(i).at(j).at(k) << '\t' << distance(ReEField.at(i).at(j).at(k), ImEField.at(i).at(j).at(k)) << endl;
//			}
//		}
//	}
//
//	cout << "Data output complete!" << endl;
//}
//
//void snapshotWrite(double k, double w0, double zR, unsigned int m, unsigned int n) {
//	char choice;
//
//	do {
//		cout << "Would you like to create snapshot data of the beam at fixed distance z? (y/n)" << endl;
//		cin >> choice;
//
//	} while (tolower(choice) != 'y' && tolower(choice) != 'n');
//
//	if (choice == 'y') {
//		double xMax; //Stores upper limit on radius of consideration
//		cout << "Enter the maximum value of x: " << endl;
//		cin >> xMax;
//
//		double xMin; //Stores upper limit on radius of consideration
//		cout << "Enter the minimum value of x: " << endl;
//		cin >> xMin;
//
//		double xInt; //Stores number of radial steps in the data output
//		cout << "Enter the step size on x: " << endl;
//		cin >> xInt;
//
//		double yMax; //Stores upper limit on radius of consideration
//		cout << "Enter the maximum value of y: " << endl;
//		cin >> yMax;
//
//		double yMin; //Stores upper limit on radius of consideration
//		cout << "Enter the minimum value of y: " << endl;
//		cin >> yMin;
//
//		double yInt; //Stores number of radial steps in the data output
//		cout << "Enter the step size on y: " << endl;
//		cin >> yInt;
//
//		double z; //Stores lower limit on distance from focus
//		cout << "Enter the distance from focus: " << endl;
//		cin >> z;
//
//		vector<double> xVals;
//		vector<double> yVals;
//
//		int xRange = (xMax - xMin) / xInt + 1;
//		int yRange = (yMax - yMin) / yInt + 1;
//
//		for (int i = 0; i < xRange; i++) { //Populate xVals
//			double xCurr = xMin + i*xInt;
//			xVals.push_back(xCurr);
//		}
//
//		for (int i = 0; i < yRange; i++) { //Populate yVals
//			double yCurr = yMin + i*yInt;
//			yVals.push_back(yCurr);
//		}
//
//		vector<vector<vector<double> > > realSnap(xVals.size(), vector<vector<double> >(yVals.size(), vector<double>(1, 0)));
//		vector<vector<vector<double> > > imagSnap(xVals.size(), vector<vector<double> >(yVals.size(), vector<double>(1, 0)));
//		vector<double> theZ;
//		theZ.push_back(z);
//
//		calculateGauss(realSnap, imagSnap, xVals, yVals, theZ, k, zR, w0, m, n);
//
//		ofstream fout2;
//		fout2.open("gaussFieldSnapshot.dat");
//		if (fout2.fail()) {
//			cerr << "Something went wrong opening output file! Exiting..." << endl;
//			exit(-1);
//		}
//
//		writeData2(realSnap, imagSnap, fout2, xVals, yVals);
//		fout2.close();
//
//		choice = 'a';
//		do {
//			cout << "Would you like to make a Fourier transform of this data? (y/n)" << endl;
//			cin >> choice;
//
//		} while (tolower(choice) != 'y' && tolower(choice) != 'n');
//
//		if (tolower(choice) == 'y') fourierTran(realSnap, imagSnap, xVals, yVals, z);
//		
//	}
//}
//
//void writeData2(vector<vector<vector<double> > > &ReEField, vector<vector<vector<double> > > &ImEField, ofstream &fout, vector<double> x, vector<double> y) { //For case of one z-value
//
//	for (int i = 0; i < x.size(); ++i) {
//		for (int j = 0; j < y.size(); ++j) {
//				//*inhales*
//				fout << x.at(i) << '\t' << y.at(j) << '\t' <<  distance(ReEField.at(i).at(j).at(0), ImEField.at(i).at(j).at(0)) << endl;
//		}
//	}
//
//}
//
//void fourierTran(vector<vector<vector<double> > > realPart, vector<vector<vector<double> > > imagPart, vector<double> xVals, vector<double> yVals, double z) { //Similar code for IFT
//	fftw_complex *in, *out;
//	in = (fftw_complex *)fftw_malloc(sizeof(fftw_complex) * realPart.size() * realPart.at(0).size());
//	out = (fftw_complex *)fftw_malloc(sizeof(fftw_complex) * realPart.size() * realPart.at(0).size());
//
//	int k = 0;
//	for (int i = 0; i < realPart.size(); ++i) {
//		for (int j = 0; j < realPart.at(0).size(); ++j) {
//			in[k][0] = realPart.at(i).at(j).at(0);
//			in[k][1] = imagPart.at(i).at(j).at(0);
//			k++;
//		}
//	}
//
//	fftw_plan g = fftw_plan_dft_2d(realPart.size(), realPart.at(0).size(), in, out, FFTW_FORWARD, FFTW_ESTIMATE);
//	fftw_execute(g);
//
//	vector<vector<vector<double> > > realFour(realPart.size(), vector<vector<double> >(realPart.at(0).size(), vector<double>(1, 0)));
//	vector<vector<vector<double> > > imagFour(imagPart.size(), vector<vector<double> >(imagPart.at(0).size(), vector<double>(1, 0)));
//	vector<double> theZ;
//	theZ.push_back(z);
//
//	k = 0;
//	for (int i = 0; i < realPart.size(); ++i) {
//		for (int j = 0; j < realPart.at(0).size(); ++j) {
//			realFour.at(i).at(j).at(0) = out[k][0];
//			imagFour.at(i).at(j).at(0) = out[k][1];
//			k++;
//		}
//	}
//
//	ofstream foutFour;
//	foutFour.open("gaussFieldFourierTrans.dat");
//	if (foutFour.fail()) {
//		cerr << "Something went wrong opening output file! Exiting..." << endl;
//		exit(2);
//	}
//
//	//writeData(realFour, imagFour, foutFour, xVals, yVals, theZ);
//	foutFour.close();
//
//	fftw_destroy_plan(g);
//	fftw_free(in);
//	fftw_free(out);
//} 
